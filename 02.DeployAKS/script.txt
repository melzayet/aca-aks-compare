As our application evolves, we want to continuously, securely, and automatically deploy it to our orchestration environment. Let's start with AKS!

In the last episode, we automated the creation of our cloud-native infrastructure. Our app will be deployed into the AKS cluster in that environment.

To deploy our app into AKS, we need a kubernetes manifest. It's a YAML based file, that points to our docker image location, defines CPU and Memory limits, creates environment variables, and a lot more. 

To deploy our manifests, we need permissions to access our AKS cluster. We could use a Kubernetes Service Account. It's a principal generated by Kubernetes. But it would be better if we can keep all principals, and identities in Azure AD. Our AKS cluster has been configured to use Azure AD for authentication. We can give our GitHub identity, permissions to deploy to AKS. Similar to what we did when creating infrastructure, our GitHub Identity will not need any credentials.  It will use "Workload Identity Federation".  

Before deploying our manifest, we have to install some dependencies. NGINX will act as a reverse-proxy. Azure Workload Identity webhook, will add credentials to our app, to be able to access Azure resources. Then our app will get deployed. Although our app and dependencies will be running on AKS nodes or VMs; the deployment took place by communicating with the Kubernetes control plane. This control plane is API based; and managed by the AKS team.  

Anytime we commit a change to our app, a GitHub workflow can now deploy that new version to AKS!

That's it. If you haven't already, please find this episode page in "depicted.cloud" website. You will find some follow-up resources.   Thanks for watching, and stay posted for a coming episode!   