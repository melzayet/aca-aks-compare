As our application evolves, we want to continuously, securely, and automatically deploy it to our orchestration environment. Let's start with AKS!

In the last episode, we automated the creation of our cloud-native infrastructure. Our app will be deployed into the AKS cluster in that environment.

To deploy our app into AKS, we need a kubernetes manifest. It's a YAML based file, that points to our docker image location, defines CPU and Memory limits, creates environment variables, and a lot more. 

To deploy our manifests, we need permissions to access our AKS cluster. We could use a Kubernetes Service Account. It's a principal generated by Kubernetes. But it would be better if we can keep all principals, and identities in Azure AD. Our AKS cluster has been configured to use Azure AD for authentication. We can give our GitHub identity, permissions to deploy to AKS. Similar to what we did when creating infrastructure, our GitHub Identity will not need any credentials.  It will use "Workload Identity Federation".  

Before deploying our manifest, we have to install some dependencies. NGINX will act as a reverse-proxy. Azure Workload Identity webhook, will add credentials to our app, to be able to access Azure resources. Then our app will get deployed. Although our app and dependencies will be running on AKS nodes or VMs; the deployment took place by communicating with the Kubernetes control plane. This control plane is API based; and managed by the AKS team.  

Anytime we commit a change to our app, a GitHub workflow can now deploy that new version to AKS!

To implement this architecture, we start by authoring the kubernetes manifest. We define the app containers, the number of replicas, exposed ports, and more. Our manifest could be packaged as helm chart, or could be run using Kubernetes client, kubectl. This is what we will be running in our GitHub worklflow. In this workflow, we will also run helm commands to install dependencies. Helm is a well-known kubernetes package manager. We already did create this deployment identity in the previous episode. Yet here we need to assign this identity an AKS role to be able to access the cluster. Our app needs some parameters like a DNS name to be accessed at. These are best stored as secrets. Now we're ready to deploy the first version of our AKS app. We just need to commit our manifest and workflow files.

We can use kubectl to list our app pods, and get the link to access the UI.

That's it. Please navigate to the below link, and inspect the files and content related to this goal. Thanks for watching, and stay posted for a coming episode!  